#!/usr/bin/env snakemake -s
##
## Snakefile to process rock/roi data
##
## Started 11th Oct 2023
##
## Izaskun Mallona
## GPLv3

# import os
import os.path as op
from glob import glob
import pandas as pd
import re

configfile: "config.yaml"

# samples = pd.read_table(config["metadata"])

# print(samples.head())
# print(samples.cb_umi_fastq.tolist())
print(config)
print(config.keys())
print(config['samples'])

def get_sample_names():
    return([x['name'] for x in config['samples']])

def get_r1_by_name(name):
    for i in range(len(config['samples'])):
        if config['samples'][i]['name'] == name:
             return(config['samples'][i]['uses']['cb_umi_fq'])

def get_r2_by_name(name):
    for i in range(len(config['samples'])):
        if config['samples'][i]['name'] == name:
             return(config['samples'][i]['uses']['cdna_fq'])

def get_expected_cells_by_name(name):
    for i in range(len(config['samples'])):
        if config['samples'][i]['name'] == name:
             return(config['samples'][i]['uses']['expected_cells'])

## old bd whitelists
def get_96x3_samples():
   matching = []
   for i in range(len(config['samples'])):
        if config['samples'][i]['uses']['whitelist'] == '96x3':
             matching.append(config['samples'][i]['name'])
   return(matching)
     

# cb1s = ['GTCGCTATA','CTTGTACTA']
# cb2s = ['TACAGGATA',]
# cb3s = ['AAGCCTTCT']

## canonical CB 9-mers or just A{9}
cb1s = ['GTCGCTATA','CTTGTACTA','CTTCACATA','ACACGCCGG','CGGTCCAGG','AATCGAATG','CCTAGTATA']
cb2s = ['TACAGGATA','CACCAGGTA','TGTGAAGAA','GATTCATCA','CACCCAAAG','CACAAAGGC','GTGTGTCGA']
cb3s = ['AAGCCTTCT','ATCATTCTG','CACAAGTAT','ACACCTTAG','GAACGACAA','AGTCTGTAC','AAATTACAG', 'AAAAAAAAA']
umis = ['AACCTTGG', 'CCGGTTAA', 'TTGGCCAA', 'GACATAGG']

rule all:
    input:
        expand(op.join('..', 'align_tso', '{sample}', 'Aligned.sortedByCoord.out.bam'),
               sample = 'simulated'),
    
rule index:
    input:
        gtf = config['gtf'],
        fa = config['genome']
    output:
        index_path =  op.join('..' , 'data', 'index', 'SAindex')
    threads:
        config['nthreads']
    params:
        simulate = config['simulate'],
        processing_path = op.join('..', 'data'),
        nthreads = config['nthreads'],
        star = config['STAR']
    log:
        op.join('..', 'data', 'index', 'indexing.log')
    shell:
      """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({params.star} --runThreadN {params.nthreads} \
     --runMode genomeGenerate \
     --sjdbGTFfile {input.gtf} \
     --genomeDir index \
     --genomeSAindexNbases 4 \
     --sjdbOverhang 100 \
     --genomeFastaFiles {input.fa} ) 2> {log}
        """

rule simulate_genome:
    output:
        op.join('..', 'data', 'genome.fa')
    shell:
        """
cat << EOF > {output}
>offtarget ERCC-00002
TCCAGATTACTTCCATTTCCGCCCAAGCTGCTCACAGTATACGGGCGTCG
GCATCCAGACCGTCGGCTGATCGTGGTTTTACTAGGCTAGACTAGCGTAC
GAGCACTATGGTCAGTAATTCCTGGAGGAATAGGTACCAAGAAAAAAACG
AACCTTTGGGTTCCAGAGCTGTACGGTCGCACTGAACTCGGATAGGTCTC
AGAAAAACGAAATATAGGCTTACGGTAGGTCCGAATGGCACAAAGCTTGT
TCCGTTAGCTGGCATAAGATTCCATGCCTAGATGTGATACACGTTTCTGG
AAACTGCCTCGTCATGCGACTGTTCCCCGGGGTCAGGGCCGCTGGTATTT
GCTGTAAAGAGGGGCGTTGAGTCCGTCCGACTTCACTGCCCCCTTTCAGC
CTTTTGGGTCCTGTATCCCAATTCTCAGAGGTCCCGCCGTACGCTGAGGA
CCACCTGAAACGGGCATCGTCGCTCTTCGTTGTTCGTCGACTTCTAGTGT
GGAGACGAATTGCCAGAATTATTAACTGCGCAGTTAGGGCAGCGTCTGAG
GAAGTTTGCTGCGGTTTCGCCTTGACCGCGGGAAGGAGACATAACGATAG
CGACTCTGTCTCAGGGGATCTGCATATGTTTGCAGCATACTTTAGGTGGG
CCTTGGCTTCCTTCCGCAGTCAAAACCGCGCAATTATCCCCGTCCTGATT
TACTGGACTCGCAACGTGGGTCCATCAGTTGTCCGTATACCAAGACGTCT
AAGGGCGGTGTACACCCTTTTGAGCAATGATTGCACAACCTGCGATCACC
TTATACAGAATTATCAATCAAGCTCCCCGAGGAGCGGACTTGTAAGGACC
GCCGCTTTCGCTCGGGTCTGCGGGTTATAGCTTTTCAGTCTCGACGGGCT
AGCACACATCTGGTTGACTAGGCGCATAGTCGCCATTCACAGATTTGCTC
GGCAATCAGTACTGGTAGGCGTTAGACCCCGTGACTCGTGGCTGAACGGC
CGTACAACTCGACAGCCGGTGCTTGCGTTTTACCCTTAAAAAAAAAAAAA
AAAAAAAAAAA
>ontarget ERCC-00003 dimer
CAGCAGCGATTAAGGCAGAGGCGTTTGTATCTGCCATTATAAAGAAGTTT
CCTCCAGCAACTCCTTTCTTAATTCCAAACTTAGCTTCAGTTATAAATTC
CCCTCCCATGATTGGGATTTTATAAACTTTTCTTCCATATAATTCATCTT
TCTTCTCATAACCGTCTCCGAAAAACTTCAACTTAAATCCAACCTTTAAC
TGCTCATCAGCCATGTCTCCCACAGCATCAAAAATAGCAGTTGTTGGACA
TGTTAAGACACACTGCCCCAATCTCTCTAACATTTGATGCTCTAACTCTG
ACTTTTTAGGGTGGCATATCTGTATTATAAATCCTGGTCTTCCATCTGGT
GTTTTTGATGGAGGGACATATTTCTCAATTCCTGCTTCTGCTGGACACAT
TATAACTGAACAACCAAAACCTGTTGCCTCTGTAGCTGCAATCTTAGCCC
ACTTCTTTGTAGCTGCTGTTATTAAAACTCTTGAAACCCATATTGGGAAT
GCTTCTGCAAATGTATCTTCAATATATACTCCATTTATTTCCATAGTTTC
CCTCCATTAAGATTTTAACAATTATAGTTTATCTTAGGGGCTATTAATAT
CTTATCATTTGGTTTTTAATATTCGATAAATCCATAAATAAAAATATATC
AACAATAATTTTAAATAATCTAAGTATAGGTAATATAACAATTAAAAAGA
TTTAGAGGGATAGAATTGAACGGCATTAGGAGAATTGTTTTAGATATATT
GAAGCCGCATGAGCCAAAAATAACAGATATGGCATTAAAATTAACATCAT
TATCAAACATTGATGGGGTTAATATTACAGTCTATGAAATAGATAAAGAG
ACTGAGAATGTTAAAGTTACAATTGAAGGGAATAATTTAGATTTTGATGA
GATTCAGGAAATTATTGAAAGTTTGGGAGGGACTATTCACAGTATAGATG
AGGTTGTTGCAGGTAAAAAGATTATTGAAGAGTTAGAACACCACAAGATA
AAAAAAAAAAAAAAAAAAAAAAACAGCAGCGATTAAGGCAGAGGCGTTTGTATCTGCCATTATAAAGAAGTTT
CCTCCAGCAACTCCTTTCTTAATTCCAAACTTAGCTTCAGTTATAAATTC
CCCTCCCATGATTGGGATTTTATAAACTTTTCTTCCATATAATTCATCTT
TCTTCTCATAACCGTCTCCGAAAAACTTCAACTTAAATCCAACCTTTAAC
TGCTCATCAGCCATGTCTCCCACAGCATCAAAAATAGCAGTTGTTGGACA
TGTTAAGACACACTGCCCCAATCTCTCTAACATTTGATGCTCTAACTCTG
ACTTTTTAGGGTGGCATATCTGTATTATAAATCCTGGTCTTCCATCTGGT
GTTTTTGATGGAGGGACATATTTCTCAATTCCTGCTTCTGCTGGACACAT
TATAACTGAACAACCAAAACCTGTTGCCTCTGTAGCTGCAATCTTAGCCC
ACTTCTTTGTAGCTGCTGTTATTAAAACTCTTGAAACCCATATTGGGAAT
GCTTCTGCAAATGTATCTTCAATATATACTCCATTTATTTCCATAGTTTC
CCTCCATTAAGATTTTAACAATTATAGTTTATCTTAGGGGCTATTAATAT
CTTATCATTTGGTTTTTAATATTCGATAAATCCATAAATAAAAATATATC
AACAATAATTTTAAATAATCTAAGTATAGGTAATATAACAATTAAAAAGA
TTTAGAGGGATAGAATTGAACGGCATTAGGAGAATTGTTTTAGATATATT
GAAGCCGCATGAGCCAAAAATAACAGATATGGCATTAAAATTAACATCAT
TATCAAACATTGATGGGGTTAATATTACAGTCTATGAAATAGATAAAGAG
ACTGAGAATGTTAAAGTTACAATTGAAGGGAATAATTTAGATTTTGATGA
GATTCAGGAAATTATTGAAAGTTTGGGAGGGACTATTCACAGTATAGATG
AGGTTGTTGCAGGTAAAAAGATTATTGAAGAGTTAGAACACCACAAGATA
AAAAAAAAAAAAAAAAAAAAAAA
EOF
        """

rule simulate_gtf:
    output:
        op.join('..', 'data', 'genome.gtf')
    shell:
        """
echo -e 'offtarget\tERCC\texon\t1\t1061\t.\t+\t.\tgene_id "offtarget"; transcript_id "offtarget_1";
ontarget\tERCC\texon\t1\t1023\t.\t+\t.\tgene_id "ontarget_1"; transcript_id "ontarget_1";
ontarget\tERCC\texon\t100\t800\t.\t+\t.\tgene_id "ontarget_1b"; transcript_id "ontarget_1b";
ontarget\tERCC\texon\t1030\t1090\t.\t+\t.\tgene_id "ontarget_2"; transcript_id "ontarget_2";' > {output}
        """

rule simulate_fastqs:
    input:
        part_r1 = expand(op.join('..', 'data', '{sample}', 'part_{cb1}_{cb2}_{cb3}_{umi}_r1.fq.gz'),
                         sample = get_sample_names(),
                         cb1 = cb1s, cb2 = cb2s, cb3 = cb3s, umi = umis),
        part_r2 = expand(op.join('..', 'data', '{sample}', 'part_{cb1}_{cb2}_{cb3}_{umi}_r2.fq.gz'),
                         sample = get_sample_names(),
                         cb1 = cb1s, cb2 = cb2s, cb3 = cb3s, umi = umis)
    params:
        path = op.join('..', 'data', '{sample}')
    output:
        r1 = op.join('..', 'data', '{sample}', 'r1.fq.gz'),
        r2 = op.join('..', 'data', '{sample}', 'r2.fq.gz'),
        r1_extra = temp(op.join('..', 'data', '{sample}', 'r1_extra.fq.gz')),
        r2_extra = temp(op.join('..', 'data', '{sample}', 'r2_extra.fq.gz')),

    shell:
        """
# cd {params.path}


seq 1 100 | awk ' {{print "@extra"$0"\\nTACTGGACTCGCAACGTGGGTCCATCAGTTGTCCGTATACCAAGACGTCTAAGGGCGGTGTACACCCTTTTGAGCAATGATTGCACAACCTGCGATCACCTTATACAGAATTATCAATCAAGCTCCCCGAGGAGCGGACTTGTAAGGACCGCCGCTTTCGCTCGGGTCTGCGG\\n+\\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";}}' | gzip -c > {output.r1_extra}

seq 1 100 | awk ' {{print "@extra"$0"\\nCTTGTACTAGTGATGTTCTCCAGACAGGCTACAGATTTGATGGTTTTTTTTTTTTTTTTT\\n+\\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";}}' | gzip -c > {output.r2_extra}

cat {input.part_r1} {output.r1_extra} > {output.r1}
cat {input.part_r2} {output.r2_extra} > {output.r2}
      """
       
rule simulate_fastqs_from_a_cell:
    output:
        part_r1 =  temp(op.join('..', 'data', '{sample}', 'part_{cb1}_{cb2}_{cb3}_{umi}_r1.fq.gz')),
        part_r2 =  temp(op.join('..', 'data', '{sample}', 'part_{cb1}_{cb2}_{cb3}_{umi}_r2.fq.gz'))
    params:
        path = op.join('..', 'data', '{sample}'),
        tso_fix1 = "AATG",
        tso_fix2 = "CCAC",
        wta_fix1 = "GTGA",
        wta_fix2 = "GACA",
    threads:
        config['nthreads']
    shell:
        """
mkdir -p {params.path}

seq 1 10 | awk  '{{print "@wta"$0"_{wildcards.cb1}{wildcards.cb1}{wildcards.cb3}{wildcards.umi}\\nTACTGGACTCGCAACGTGGGTCCATCAGTTGTCCGTATACCAAGACGTCTAAGGGCGGTGTACACCCTTTTGAGCAATGATTGCACAACCTGCGATCACCTTATACAGAATTATCAATCAAGCTCCCCGAGGAGCGGACTTGTAAGGACCGCCGCTTTCGCTCGGGTCTGCGG\\n+\\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";}}' | gzip -c > {output.part_r1}

seq 1 10 | awk ' {{print "@wta"$0"_{wildcards.cb1}{wildcards.cb1}{wildcards.cb3}{wildcards.umi}\\nA{wildcards.cb1}{params.wta_fix1}{wildcards.cb2}{params.wta_fix2}{wildcards.cb3}{wildcards.umi}AGATTTGATGGTTTTT\\n+\\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";}}' | gzip -c > {output.part_r2}

## similarly for region 1000-1100 for ontargets/tso

seq 11 20 | awk ' {{print "@tso"$0"\\nATTATTGAAGAGTTAGAACACCACAAGATAAAAAAAAAAAAAAAAAAAAAAAACAGCAGCGATTAAGGCAGAGGCGTTTGTATCTGCCATTATAAAGAAGTTTCCTCCAGCAACTCCTTTCTTAATTCCAAACTTAGC\\n+\\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";}}' | gzip -c >> {output.part_r1}

seq 11 20 | awk  ' {{print "@tso"$0"_{wildcards.cb1}{wildcards.cb1}{wildcards.cb3}{wildcards.umi}\\nT{wildcards.cb1}{params.tso_fix1}{wildcards.cb2}{params.tso_fix2}{wildcards.cb3}{wildcards.umi}TTTTTTTTTTTTTTTT\\n+\\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";}}' | gzip -c >> {output.part_r2}

## another ontarget region - TSO barcode
## same UMI 100 times
seq 21 30 | awk ' {{print "@tso"$0"_{wildcards.cb1}{wildcards.cb1}{wildcards.cb3}{wildcards.umi}\\nATTCCAAACTTAGCTTCAGTTATAAATTCCCCTCCCATGATTGGGATTTTATAAACTTTTCTTCCATATAATTCATCTTTCTTCTCATAACCGTCTCCGAAAAACTTCAACTTAAATCCAACCTTTAACTGCTCATCA\\n+\\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";}}' | gzip -c >> {output.part_r1}

seq 21 30 | awk ' {{print "@tso"$0"_{wildcards.cb1}{wildcards.cb1}{wildcards.cb3}{wildcards.umi}\\nG{wildcards.cb1}{params.tso_fix1}{wildcards.cb2}{params.tso_fix2}{wildcards.cb3}{wildcards.umi}TTTTTTTTTTTTTTTT\\n+\\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";}}' | gzip -c >> {output.part_r2}
      """


rule retrieve_whitelist:
    output:
        op.join('..', 'data', 'whitelists', 'BD_CLS1.txt'),
        op.join('..', 'data', 'whitelists', 'BD_CLS2.txt'),
        op.join('..', 'data', 'whitelists', 'BD_CLS3.txt')
    params:
        path = op.join('..', 'data', 'whitelists')
    shell:
        """
        mkdir -p {params.path}
        cd {params.path}
        wget https://teichlab.github.io/scg_lib_structs/data/BD_CLS1.txt
        wget https://teichlab.github.io/scg_lib_structs/data/BD_CLS2.txt
        wget https://teichlab.github.io/scg_lib_structs/data/BD_CLS3.txt
        """

rule align_wta_96x3:
    input:
        r1 = op.join('..', 'data', "{sample}", 'r1.fq.gz'),
        r2 = op.join('..', 'data', "{sample}", 'r2.fq.gz'),
        index_flag = op.join('..' , 'data', 'index', 'SAindex'),
        gtf = config['gtf'],
        cb1 = op.join('..', 'data', 'whitelists', 'BD_CLS1.txt'),
        cb2 = op.join('..', 'data', 'whitelists', 'BD_CLS2.txt'),
        cb3 = op.join('..', 'data', 'whitelists', 'BD_CLS3.txt')
    output:
        bam = op.join('..', 'align_wta', '{sample}', 'Aligned.sortedByCoord.out.bam'),
        filtered_barcodes = op.join('..', 'align_wta', '{sample}', 'Solo.out', 'Gene',
                                    'filtered', 'barcodes.tsv')
    params:
        path = op.join('..', 'align_wta', "{sample}/"),
        index_path = op.join('..' , 'data', 'index'),
        STAR = config['STAR'],
        threads = 5, # config['nthreads'],
        # num_cells = get_expected_cells_by_name("{sample}"),
        num_cells = 2,
        tmp = op.join('..', 'tmp_align_wta_{sample}'),
        maxmem = config['per_task_max_mem']
    shell:
        """
   rm -rf {params.tmp}
   mkdir -p {params.path} 

   {params.STAR} --runThreadN {params.threads}\
     --genomeDir {params.index_path} \
     --readFilesCommand zcat \
     --outFileNamePrefix {params.path} \
     --readFilesIn  {input.r1} {input.r2}  \
     --soloType CB_UMI_Complex \
     --soloAdapterSequence GTGANNNNNNNNNGACA \
     --soloCBposition 2_-9_2_-1 2_4_2_12 2_17_2_25 \
     --soloUMIposition 3_10_3_17 \
     --soloCBwhitelist {input.cb1} {input.cb2} {input.cb3} \
     --soloCBmatchWLtype 1MM \
     --soloCellFilter EmptyDrops_CR \
     --outSAMattributes NH HI AS nM NM MD jM jI MC ch CB UB gx gn sS CR CY UR UY\
     --soloCellReadStats Standard \
     --sjdbOverhang 100 \
     --outSAMtype BAM SortedByCoordinate \
     --quantMode GeneCounts \
     --soloUMIlen 8 \
     --sjdbGTFfile {input.gtf} \
     --outTmpDir {params.tmp} \
     --limitBAMsortRAM {params.maxmem}

    rm -rf {params.tmp}
        """

        
rule generate_tso_whitelist_from_wta_filtered:
    input:
        filtered_barcodes = op.join('..', 'align_wta', '{sample}', 'Solo.out', 'Gene',
                                    'filtered', 'barcodes.tsv')
    output:
        tso_whitelist = op.join('..', 'data', '{sample}', 'tso_whitelist.txt')
    params:
        path = op.join('..', 'data', '{sample}')
    shell:
        """
        mkdir -p {params.path}
        awk -F "_" '{{print $1"AATG"$2"CCAC"$3}}' {input.filtered_barcodes} > {output.tso_whitelist}
        """
        

rule align_tso_96x3:
    input:
        r1 = op.join('..', 'data', "{sample}", 'r1.fq.gz'),
        r2 = op.join('..', 'data', "{sample}", 'r2.fq.gz'),
        index_flag = op.join('..' , 'data', 'index', 'SAindex'),
        gtf = config['gtf'],
        tso_whitelist = op.join('..', 'data', '{sample}', 'tso_whitelist.txt'),
        filtered_barcodes = op.join('..', 'align_wta', '{sample}', 'Solo.out', 'Gene',
                                    'filtered', 'barcodes.tsv')
    output:
        bam = op.join('..', 'align_tso', '{sample}', 'Aligned.sortedByCoord.out.bam')
    params:
        path = op.join('..', 'align_tso', "{sample}/"),
        index_path = op.join('..' , 'data', 'index'),
        STAR = config['STAR'],
        threads = 5, #config['nthreads'],
        tmp = op.join('..', 'tmp_align_tso_{sample}'),
        maxmem = config['per_task_max_mem']
    shell:
        """
   rm -rf {params.tmp}
   mkdir -p {params.path} 

   {params.STAR} --runThreadN {params.threads}\
     --genomeDir {params.index_path} \
     --readFilesCommand zcat \
     --outFileNamePrefix {params.path} \
     --readFilesIn  {input.r1} {input.r2}  \
     --soloType CB_UMI_Complex \
     --soloCBmatchWLtype 1MM \
     --soloAdapterSequence NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN \
     --soloCBposition 2_1_2_35 \
     --soloUMIposition 3_1_3_8 \
     --soloCBwhitelist {input.tso_whitelist} \
     --soloUMIlen 8 \
     --soloCellFilter None \
     --outSAMattributes NH HI AS nM NM MD jM jI MC ch CB UB gx gn sS CR CY UR UY\
     --soloCellReadStats Standard \
     --sjdbOverhang 100 \
     --outSAMtype BAM SortedByCoordinate \
     --quantMode GeneCounts \
     --sjdbGTFfile {input.gtf} \
     --outTmpDir {params.tmp} \
     --limitBAMsortRAM {params.maxmem}

    rm -rf {params.tmp}
        """
